# Merkle Patricia Trie

## Patricia trie

Patricia trie 是一种数据结构，也称为前缀树、基数树或 trie。Trie 使用键作为路径，因此共享相同前缀的节点也可以共享相同的路径。这种结构查找公共前缀的速度最快，实现简单，并且需要的内存较小。因此，它通常用于在计算机网络中实现路由表，以及在路由器等低规格机器中使用的系统。


## 1.Merkle trie

Merkle 树是一棵哈希树。叶节点存储数据。父节点包含其子节点的哈希值以及其子节点哈希值之和的哈希值。由于除叶子节点外的所有节点都包含哈希值，因此 Merkle 树也称为哈希树。

使用 Merkle 树可以有效地找出两个不同节点是否具有相同的数据。首先必须比较两个节点的 Top Hash 值。如果相同，则两个节点具有相同的数据。例如，在上图中，当有四个节点（L1，L2，L3，L4）时，你只需要检查它们是否具有相同的Top Hash。如果Top Hash不同，你想知道哪些数据不同，你应该比较Hash 0和Hash1，看看哪个分支不同。通过这样做，您最终会发现哪些数据不同。

##2. Merkle Patricia Trie

以太坊Merkle Patricia Trie是结合了上面两种树的数据结构，兼顾了查询和安全性。

在MPT中，以及在Merkle树中，每个节点都有一个哈希值。每个节点的哈希值由其内容的 sha3 哈希值决定。该哈希值也用作引用节点的密钥。Go-ethereum使用levelDB，parity使用rocksDB来存储状态。它们是键值存储。存储中保存的键和值不是以太坊状态的键值。存储中存储的值是MPT节点的内容，而键是该节点的哈希值。

以太坊状态的键值用作 MPT 上的路径。Nibble是MPT中用来区分键值的单位，因此每个节点最多可以有16个分支。另外，由于节点有自己的值，因此分支节点是由 1 个节点值和 16 个分支组成的 17 项数组。

没有子节点的 Node 称为叶节点。叶节点由两项组成：路径和值。例如，假设键“0xBEA”包含 1000，键“0xBEE”包含 2000。那么，应该有一个具有“0xBE”路径的分支节点，并且在该节点下有两个具有两条路径的叶节点（“ 0xA”和“0xE”）将被附加。

在MPT中，除了分支节点和叶节点之外，还多了一种类型的节点。它们是扩展节点。扩展节点是分支节点的优化节点。在以太坊状态下，经常出现只有一个子节点的分支节点。这就是 MPT 将仅包含一个子节点的分支节点压缩为具有路径和子节点哈希的扩展节点的原因。

由于叶节点和扩展节点都是包含两个项目的数组，因此应该有一种方法来区分这两个不同的节点。为了进行这种区分，MPT 在路径中添加前缀。如果节点是叶子并且路径由偶数个半字节组成，则添加 0x20 作为前缀。如果路径由奇数个半字节组成，则应添加 0x3 作为前缀。如果节点是扩展节点并且路径由偶数个半字节组成，则添加 0x00 作为前缀。如果它由奇数个半字节组成，则应添加 0x1 作为前缀。因为由奇数个半字节组成的路径得到一个半字节作为前缀，而由偶数个半字节组成的路径得到两个半字节作为前缀，所以路径总是表示为一个字节。

## 3.节点类型

按功能不同，存在4种节点：

1. NULL节点
2. 分支节点，含有17项数据，[ v0 … v15, vt ]
3. 叶节点，含有2项数据，[ encodedPath, value ]
4. 扩展节点，含有两项数据，[ encodedPath, key ]

`Merkle Patricia Trie`查询路径是以`nibble`(半个字节）作为单位。
分支节点中的前16项数据v0-v15分别对应16进制的0-0xF，是用`nibble`作为索引，可以快速进行查询，比如路径`nibble`是0xa，则取分支节点0xa位置的值。分支节点对应图上的分叉节点。
叶节点和扩展节点都是两项，只是`value`不同，以太坊采用添加前缀的方式来区分它们，根据节点类型和路径长度是否是奇偶数来添加不同的前缀。
有一个对应表：

| hex char | bits | node type partial  | path length |
| :------- | :--- | :----------------- | :---------- |
| 0        | 0000 | extension          | even(偶数)  |
| 1        | 0001 | extension          | odd(奇数)   |
| 2        | 0010 | terminating (leaf) | even(偶数)  |
| 3        | 0011 | terminating (leaf) | odd(奇数)   |

可以看到前缀为0或者1时表示扩展节点，2或者3时表示叶节点。
另外前缀为0或者2时，需要变更为00或20.

4. 安全性

以上介绍的MPT树，可以用来存储内容为任何长度的key-value数据项。倘若数据项的key长度没有限制时，当树中维护的数据量较大时，仍然会造成整棵树的深度变得越来越深，会造成以下影响：

1.查询一个节点可能会需要许多次IO读取，效率低下

2.系统易遭受Dos攻击，攻击者可以通过在合约中存储特定的数据，“构造”一棵拥有一条很长路径的树，然后不断地调用SLOAD指令读取该树节点的内容，造成系统执行效率极度下降

3.所有的key其实是一种明文的形式进行存储

为了解决以上问题，在以太坊中对MPT再进行了一次封装，对数据项的key进行了一次哈希计算，因此最终作为参数传入到MPT接口的数据项其实是 `(sha3(key), value)`

## 4.具体结构

这里使用不同的header值来表示不同的节点类型，即01表示叶子节点，10表示无值的分支节点，11表示有值的分支节点。

之后将节点进行Hash：


首先计算出叶子节点的哈希值，它们被上一级的分支节点所引用，用来在数据库中查找对应的节点；然后计算分支节点的哈希值，直至递归抵达根节点。
